/// Static Exchange Evaluation (SEE)
///
/// Evaluates the material outcome of a capture sequence at a given square.
/// Returns the expected material gain/loss from the perspective of the moving player.
///
/// Improved version that properly checks if pieces can actually attack the target square.
use crate::core::{Board, Move, PlayerId, Position};
use crate::logic::apply_move;
use crate::player::ai::eval::piece_val;

pub fn static_exchange_eval(board: &Board, mv: &Move, player: PlayerId) -> i32 {
    // Only evaluate capture moves
    let (from, to, _promote) = match mv {
        Move::Normal { from, to, promote } => (from, to, promote),
        Move::Drop { .. } => return 0, // Drops don't have SEE
    };

    // Get the captured piece value
    let captured_piece = match board.get_piece(*to) {
        Some(p) if p.owner != player => piece_val(p.kind),
        _ => return 0, // No capture
    };

    // Get the attacking piece value
    let attacker = match board.get_piece(*from) {
        Some(p) => piece_val(p.kind),
        None => return 0,
    };

    // Check if the target square is defended by the opponent
    let defenders = count_attackers(board, *to, player.opponent());

    if defenders == 0 {
        // No defenders, safe capture
        return captured_piece;
    }

    // Simple 2-level SEE: we capture, opponent recaptures
    // More sophisticated would simulate the full exchange sequence
    let net_gain = captured_piece - attacker;

    // Check if we also defend the square
    let our_defenders = count_attackers(board, *to, player);

    if our_defenders > 1 {
        // We have multiple defenders, likely favorable
        // Simplified: assume we can recapture
        return net_gain.max(captured_piece / 2); // Conservative estimate
    }

    net_gain
}

/// Count how many pieces of a given player can attack a target square.
/// Optimized version using direct attack pattern checking instead of legal move generation.
fn count_attackers(board: &Board, target: Position, attacker: PlayerId) -> usize {
    let mut count = 0;

    for (&pos, piece) in &board.pieces {
        if piece.owner == attacker {
            if can_piece_attack(board, pos, target, piece.kind, attacker) {
                count += 1;
            }
        }
    }

    count
}

/// Check if a piece at `from` can attack `to` square using direct pattern matching.
fn can_piece_attack(
    board: &Board,
    from: Position,
    to: Position,
    piece_kind: crate::core::PieceKind,
    owner: PlayerId,
) -> bool {
    use crate::core::PieceKind::*;

    if from == to {
        return false;
    }

    let dx = to.x as i32 - from.x as i32;
    let dy = to.y as i32 - from.y as i32;

    // Direction from owner's perspective (Player1 moves down, Player2 moves up)
    let forward = if owner == PlayerId::Player1 { 1 } else { -1 };

    match piece_kind {
        // Pawn: one square forward
        Pawn => dx == 0 && dy == forward,

        // Lance: any number of squares forward
        Lance => dx == 0 && dy * forward > 0 && is_path_clear(board, from, to),

        // Knight: L-shape jump (2 forward, 1 left/right)
        Knight => dx.abs() == 1 && dy == 2 * forward,

        // Silver: 5 directions (forward, forward-diagonals, back-diagonals)
        Silver => {
            (dx == 0 && dy == forward) || // Forward
            (dx.abs() == 1 && dy == forward) || // Forward diagonals
            (dx.abs() == 1 && dy == -forward) // Back diagonals
        }

        // Gold: 6 directions (all adjacent except back diagonals)
        Gold => {
            (dx == 0 && dy.abs() == 1) || // Forward/backward
            (dx.abs() == 1 && dy == 0) || // Left/right
            (dx.abs() == 1 && dy == forward) // Forward diagonals only
        }

        // Bishop: any diagonal
        Bishop => dx.abs() == dy.abs() && dx != 0 && is_path_clear(board, from, to),

        // Rook: any horizontal or vertical
        Rook => (dx == 0 || dy == 0) && is_path_clear(board, from, to),

        // King: one square in any direction
        King => dx.abs() <= 1 && dy.abs() <= 1,

        // Promoted pieces (follow Gold pattern + original movement)
        PieceKind::ProPawn | PieceKind::ProLance | PieceKind::ProKnight | PieceKind::ProSilver => {
            // All promoted pieces move like Gold
            (dx == 0 && dy.abs() == 1)
                || (dx.abs() == 1 && dy == 0)
                || (dx.abs() == 1 && dy == forward)
        }

        // Promoted Bishop (Horse): Bishop + King
        ProBishop => {
            // Can move like Bishop
            (dx.abs() == dy.abs() && dx != 0 && is_path_clear(board, from, to)) ||
            // Or one square in any direction (King move)
            (dx.abs() <= 1 && dy.abs() <= 1)
        }

        // Promoted Rook (Dragon): Rook + King
        ProRook => {
            // Can move like Rook
            ((dx == 0 || dy == 0) && is_path_clear(board, from, to)) ||
            // Or one square diagonally (King diagonal move)
            (dx.abs() == 1 && dy.abs() == 1)
        }

        // Chess pieces (for mixed boards)
        ChessPawn => {
            // Chess pawns attack diagonally forward
            dx.abs() == 1 && dy == forward
        }

        ChessKnight => {
            // Standard L-shape: (2,1) or (1,2) in any direction
            (dx.abs() == 2 && dy.abs() == 1) || (dx.abs() == 1 && dy.abs() == 2)
        }

        ChessBishop => dx.abs() == dy.abs() && dx != 0 && is_path_clear(board, from, to),

        ChessRook => (dx == 0 || dy == 0) && is_path_clear(board, from, to),

        ChessQueen => {
            // Queen = Rook + Bishop
            ((dx == 0 || dy == 0) || (dx.abs() == dy.abs())) && is_path_clear(board, from, to)
        }
    }
}

/// Check if the path between two squares is clear (for sliding pieces).
fn is_path_clear(board: &Board, from: Position, to: Position) -> bool {
    let dx = (to.x as i32 - from.x as i32).signum();
    let dy = (to.y as i32 - from.y as i32).signum();

    let mut x = from.x as i32 + dx;
    let mut y = from.y as i32 + dy;

    while x != to.x as i32 || y != to.y as i32 {
        // Check bounds
        if x < 0 || x >= 9 || y < 0 || y >= 9 {
            return false;
        }

        let pos = Position {
            x: x as usize,
            y: y as usize,
        };

        if board.get_piece(pos).is_some() {
            return false; // Path blocked
        }

        x += dx;
        y += dy;
    }

    true
}

/// Check if a specific square is attacked by a player.
/// More efficient than count_attackers when you only need yes/no.
pub fn is_square_attacked(board: &Board, target: Position, attacker: PlayerId) -> bool {
    count_attackers(board, target, attacker) > 0
}

/// Enhanced SEE with hanging piece detection.
/// Returns a penalty if moving a piece leaves it hanging (undefended and attackable).
pub fn evaluate_move_safety(board: &Board, mv: &Move, player: PlayerId) -> i32 {
    let mut safety_score = 0;

    // 1. Evaluate the capture (if any)
    safety_score += static_exchange_eval(board, mv, player);

    // 2. Check if the moved piece will be hanging after the move
    let to_pos = match mv {
        Move::Normal { to, .. } => *to,
        Move::Drop { to, .. } => *to,
    };

    // Simulate the move
    let next_board = apply_move(board, mv, player);

    // Check if the piece at the destination is now attacked
    let is_attacked = is_square_attacked(&next_board, to_pos, player.opponent());

    if is_attacked {
        // Check if it's defended
        let is_defended = is_square_attacked(&next_board, to_pos, player);

        if !is_defended {
            // Piece is hanging! Apply penalty
            let piece_val = match next_board.get_piece(to_pos) {
                Some(p) if p.owner == player => piece_val(p.kind),
                _ => 0,
            };
            safety_score -= piece_val; // Full penalty for hanging piece
        } else {
            // Piece is attacked but defended - small penalty for risk
            safety_score -= 50;
        }
    }

    safety_score
}
